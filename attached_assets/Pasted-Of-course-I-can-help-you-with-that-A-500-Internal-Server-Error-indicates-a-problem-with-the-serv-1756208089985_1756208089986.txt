Of course, I can help you with that. A "500 Internal Server Error" indicates a problem with the server-side code. After reviewing your files, I've identified the likely cause of the issue and a way to fix it.

### The Problem

The error is most likely happening because of how the `app.py` script is trying to tell the `main.py` script which PDF to translate.

Currently, `app.py` opens `main.py`, modifies its content to set the `input_pdf` variable, saves the changes, and then runs the modified script. This approach is problematic for a few reasons:

1.  **File Permissions**: The server environment might restrict one script from modifying another while it's running, which would cause the application to crash and result in a 500 error.
2.  **Race Conditions**: If two users try to translate different PDFs at the same time, they would overwrite each other's changes to `main.py`, leading to incorrect translations or errors.

### The Solution

A more robust and standard way to handle this is to pass the PDF filename from `app.py` to `main.py` as a command-line argument. This avoids modifying the script file altogether.

Here are the necessary changes for `app.py` and `main.py`:

-----

### 1\. Update `app.py`

In `app.py`, you need to change the `/translate` route. Instead of reading and writing to `main.py`, you will now pass the `pdf_file` directly in the `subprocess.run` command.

**Replace this code in `app.py`:**

```python
        # Update the main.py configuration
        with open('main.py', 'r') as f:
            content = f.read()

        # Replace the input_pdf value
        lines = content.split('\n')
        for i, line in enumerate(lines):
            if line.startswith('input_pdf = '):
                lines[i] = f'input_pdf = "{pdf_file}"'
                break

        with open('main.py', 'w') as f:
            f.write('\n'.join(lines))

        # Run the translation
        result = subprocess.run(['python', 'main.py'], 
                              capture_output=True, text=True, timeout=600)
```

**With this improved code:**

```python
        # Run the translation, passing the PDF file as a command-line argument
        result = subprocess.run(['python', 'main.py', pdf_file], 
                              capture_output=True, text=True, timeout=600)
```

-----

### 2\. Update `main.py`

Next, modify `main.py` to read the filename from the command-line arguments instead of a hardcoded variable.

**Make these changes in `main.py`:**

1.  **Import the `sys` module** at the top of the file:

    ```python
    import fitz  # PyMuPDF
    import os
    import time
    from openai import OpenAI
    from replit.object_storage import Client
    import sys
    ```

2.  **Remove or comment out** the hardcoded `input_pdf` variable:

    ```python
    # --- Configuration ---
    # 1. Name of the PDF you want to translate
    # input_pdf = "louiseeliasbergs1996bowe.pdf" # This will now be passed as an argument
    ```

3.  **Update the main execution block** at the very end of the file to read the argument:

    **Replace this:**

    ```python
    # --- Run the script ---
    if __name__ == "__main__":
        translate_pdf_with_bolding(input_pdf, output_pdf, font_path_regular, font_path_bold)
    ```

    **With this:**

    ```python
    # --- Run the script ---
    if __name__ == "__main__":
        if len(sys.argv) > 1:
            # Get the input PDF filename from the first command-line argument
            input_pdf_from_arg = sys.argv[1]
            translate_pdf_with_bolding(input_pdf_from_arg, output_pdf, font_path_regular, font_path_bold)
        else:
            # Print an error if no file is provided, which helps with debugging
            print("ERROR: No input PDF file was specified as a command-line argument.")
    ```

By making these changes, you create a much more stable and reliable system for handling translations. This should resolve the 500 error you are seeing.